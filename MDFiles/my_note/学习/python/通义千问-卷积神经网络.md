基于PyTorch构建的基础卷积神经网络（CNN）模型用于图像分类的例子。这里我们以CIFAR-10数据集为例，它包含10种类别的32x32彩色图片。

```python
import torch
import torch.nn as nn
import torch.optim as optim

# 定义一个简单的卷积神经网络模型
class SimpleCNN(nn.Module):
    def __init__(self, num_classes=10):
        super(SimpleCNN, self).__init__()
        
        # 卷积层和池化层堆叠
        self.features = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, padding=1),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2),
            nn.Conv2d(16, 32, 3, padding=1),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(2),
        )
        
        # 全连接层
        self.classifier = nn.Sequential(
            nn.Linear(32 * 8 * 8, 512),  # 假设经过前面的卷积和池化后特征图大小为8*8
            nn.ReLU(inplace=True),
            nn.Dropout(p=0.5),  # 防止过拟合
            nn.Linear(512, num_classes)  # 输出层，num_classes是类别数
        )

    def forward(self, x):
        x = self.features(x)
        x = x.view(-1, 32 * 8 * 8)  # 将卷积后的输出展平
        x = self.classifier(x)
        return x

# 初始化模型、损失函数和优化器
model = SimpleCNN()
criterion = nn.CrossEntropyLoss()  # 多类交叉熵损失函数
optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)  # 使用随机梯度下降优化器

# 训练过程在此省略，包括加载数据、前向传播、计算损失、反向传播和更新权重等步骤...

import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.optim as optim

# 设定设备，可以在GPU上运行如果可用
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

# 定义并初始化模型
class SimpleCNN(nn.Module):
    # ... (同上定义SimpleCNN)

model = SimpleCNN().to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)

# 数据预处理与加载
transform = transforms.Compose([
    transforms.RandomHorizontalFlip(),
    transforms.RandomCrop(32, padding=4),
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),
])

trainset = torchvision.datasets.CIFAR10(root='./data', train=True,
                                        download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=100,
                                          shuffle=True, num_workers=2)

testset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=100,
                                         shuffle=False, num_workers=2)

# 开始训练
num_epochs = 10
for epoch in range(num_epochs):
    running_loss = 0.0
    for i, data in enumerate(trainloader, 0):
        inputs, labels = data
        inputs, labels = inputs.to(device), labels.to(device)

        optimizer.zero_grad()

        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()
    print(f'Epoch {epoch + 1}, Loss: {running_loss / (i + 1)}')

# 在测试集上评估模型
model.eval()
correct = 0
total = 0
with torch.no_grad():
    for data in testloader:
        images, labels = data
        images, labels = images.to(device), labels.to(device)
        outputs = model(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print(f'Accuracy of the model on the 10000 test images: {100 * correct / total}%')
# 注意，在实际项目中，您可能还需要加入学习率衰减策略，以及早停策略等来优化模型性能。此外，上述代码没有实现模型保存和加载的功能，如果需要在训练完成后保存模型并在未来恢复模型状态，可以使用torch.save() 和 torch.load() 方法。


```

这个模型首先通过两个卷积层和池化层提取图像特征，然后通过全连接层进行分类。实际应用中可能需要根据任务的具体需求调整网络结构（例如添加更多卷积层或使用更复杂的模型如ResNet、VGG等），同时还需要编写相应的训练和验证逻辑。