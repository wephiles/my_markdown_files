# 2014年及之前

![7D857324E4DA547547599031D6D23D37](D:\TextFiles\MDFiles\my_note\学习\考研复试\assets\7D857324E4DA547547599031D6D23D37.jpg)

![783FCBB1310864F5701C2FF3F8B801B1](D:\TextFiles\MDFiles\my_note\学习\考研复试\assets\783FCBB1310864F5701C2FF3F8B801B1-1708605186921-3.jpg)

![FF649C8B15F3DC9D8D9B00C26CC2EC36](D:\TextFiles\MDFiles\my_note\学习\考研复试\assets\FF649C8B15F3DC9D8D9B00C26CC2EC36.jpg)

1. 什么是物联网

    物联网（Internet of Things，简称IoT）**是一种将各种信息传感设备、网络连接设备、智能终端等与互联网相连接的网络概念**。它允许这些设备通过信息传播媒介进行信息交换和通信，实现智能化的识别、定位、跟踪、监控和管理等功能。**物联网的核心和基础是互联网，它是互联网在物理世界中的延伸和扩展，具有互联互通、智能化、自动化等特点。**

2. java的特点：

    ```python
    简单性：Java的语法与C和C++相似，但去除了C++中一些复杂且很少使用的特性，如操作符重载、多继承和自动类型转换。Java不使用指针，而是使用引用，简化了内存管理。 
    
    面向对象：Java是纯粹的面向对象语言，支持类、对象、继承、封装和多态等面向对象的特性。它只支持类之间的单继承，但允许接口之间的多继承。
    
    分布式：Java提供了网络应用编程接口（java.net），支持分布式系统开发，如远程方法调用（RMI）。
    
    健壮性：Java的强类型机制、异常处理和垃圾回收机制有助于提高程序的健壮性。
    
    安全性：Java提供了安全机制，如类加载器（ClassLoader）和安全管理器（SecurityManager），以防止恶意代码的攻击。
    
    平台独立性（可移植性）：Java程序编译成字节码（.class文件），可以在任何安装了Java虚拟机（JVM）的平台上运行，实现了“一次编写，到处运行”的理念。
    
    解释型：Java程序在JVM上被编译为字节码后，由JVM解释执行，这使得Java程序可以在不同的操作系统上运行，而无需重新编译。
    
    高性能：随着JIT（Just-In-Time）编译器技术的发展，Java程序的执行速度越来越接近于C++。
    
    多线程：Java支持多线程编程，允许同时执行多个任务，提供了线程同步机制（如synchronized关键字）来管理线程间的交互。
    
    动态性：Java程序可以在运行时动态加载类，支持动态链接，这有助于软件的升级和维护。
    ```

3. 程序的多态性
    ```python
    程序的多态性（Polymorphism）是面向对象编程（OOP）的一个核心概念，它指的是同一个接口可以被不同的类实现，或者一个类可以有多个行为。多态性允许程序在运行时根据对象的实际类型来调用相应的方法，而不是在编译时就确定。这提供了一种灵活的方式来处理不同类型对象的共同行为，使得代码更加通用和可扩展。
    
    多态性主要体现在以下几个方面：
    
    方法重载（Overloading）：在同一个类中，可以有多个同名的方法，但它们的参数列表（参数的类型、数量或顺序）必须不同。编译器会根据方法签名（即方法名和参数列表）来确定调用哪个方法。
    
    方法覆盖（Overriding）：在子类中，可以覆盖（Override）父类中的方法。子类的方法与父类的方法同名，并且具有相同的参数列表。在运行时，如果对象是子类的实例，那么调用该方法时会执行子类中的方法，而不是父类中的同名方法。
    
    接口实现：一个类可以实现一个或多个接口，接口中定义了一组方法的声明。实现接口的类必须提供这些方法的具体实现。在运行时，通过接口类型的引用调用方法时，会根据引用所指向的实际对象的类型来确定执行哪个实现。
    ```

4. 什么是软件工程？为什么叫软件工程？
    ```python
    软件工程（Software Engineering）是一门应用工程学的思想、方法和技术来系统地开发和维护软件的学科。它涉及到软件生命周期的各个阶段，包括需求分析、设计、编码、测试、部署、维护和项目管理等。软件工程的目标是高效、经济地生产出高质量的软件产品，这些产品能够在实际机器上可靠地运行。
    
    软件工程之所以被称为“工程”，是因为它借鉴了传统工程领域的许多原则和实践，如系统化的方法、严格的项目管理、质量保证、风险评估和成本效益分析等。这些工程化的方法有助于提高软件开发的效率，减少错误和缺陷，确保软件项目能够按时、按预算完成，并满足用户的需求。
    ```

5. 冯诺依曼计算机五大基本组成部件
    ```python
    运算器（Arithmetic Logic Unit, ALU）：这是计算机中执行算术和逻辑运算的部分，负责处理数据，进行加、减、乘、除等算术运算以及逻辑运算（如与、或、非等）。
    
    控制器（Control Unit, CU）：控制器负责从存储器中获取指令，解释指令，然后向计算机的其他部分发送控制信号，以执行指令。它是计算机的指挥中心，确保程序按照正确的顺序执行。
    
    存储器（Memory）：存储器用于存储程序和数据。它包括主存储器（RAM）和辅助存储器（如硬盘、固态硬盘等）。主存储器是计算机运行时直接访问的存储空间，而辅助存储器则用于长期存储数据。
    
    输入设备（Input Devices）：输入设备允许用户向计算机提供数据和指令。常见的输入设备包括键盘、鼠标、触摸屏、扫描仪等。
    
    输出设备（Output Devices）：输出设备用于将计算机处理的结果展示给用户。常见的输出设备包括显示器、打印机、扬声器等。
    ```

6. 进程与线程
    ```python
    定义：
    进程：进程是操作系统资源分配和调度的基本单位，它是一个正在运行的程序的实例。每个进程都有自己的内存空间（包括代码、数据和堆栈），以及一个唯一的进程标识符（PID）。进程可以包含一个或多个线程。
    线程：线程是进程中的一个执行单元，是CPU调度和分派的基本单位。线程共享其所属进程的资源（如内存空间），但拥有自己的执行栈和程序计数器。线程是轻量级的，比进程更小，创建和切换的开销较小。
    
    资源开销：
    进程：每个进程都有独立的内存空间，进程间的切换（上下文切换）开销较大，因为需要保存和恢复整个进程的状态。
    线程：线程共享进程的内存空间，每个线程有自己的执行栈和程序计数器。线程间的切换开销较小，因为它们共享大部分资源。
    
    包含关系：
    进程：一个进程可以包含多个线程，这些线程可以并发执行，共同完成进程的任务。
    线程：线程是进程的一部分，一个进程至少有一个线程（通常称为主线程）。
    
    内存分配：
    进程：进程间地址空间相互独立，互不影响。
    线程：同一进程的线程共享地址空间，包括堆和方法区（在Java中称为元空间），但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。
    
    影响关系：
    进程：一个进程崩溃通常不会影响其他进程。
    线程：一个线程崩溃可能导致整个进程崩溃，因为线程共享进程资源。
    
    执行过程：
    进程：每个进程有独立的执行入口、顺序执行序列和退出点。
    线程：线程不能独立执行，必须依赖于进程，由进程提供执行控制。
    ```

7. 死锁的原因与解决方法
    ```python
    死锁（Deadlock）是指在多任务系统中，两个或多个进程在执行过程中因争夺资源而造成的一种僵局，这些进程互相等待对方释放资源，但又都无法继续执行。死锁的产生通常需要满足以下四个条件：
    
    互斥条件：资源至少有一个是不可共享的，即一次只能被一个进程使用。
    占有和等待条件：进程在占有资源的同时，又等待其他进程释放它所占用的资源。
    不可抢占条件：进程占有的资源在未使用完之前，不能被其他进程抢占。
    循环等待条件：存在一组进程，其中每个进程都在等待下一个进程所占有的资源。
    死锁的解决方法主要有以下几种：
    
    死锁预防：通过破坏死锁产生的四个条件之一来预防死锁。
    破坏互斥条件：在某些情况下，可以尝试将资源设计为可共享的，而不是互斥的。例如，如果资源的共享使用不会导致数据不一致，那么可以允许多个进程同时访问该资源。
    破坏占有并等待条件：要求进程在开始执行之前一次性申请所有所需的资源。这样，如果进程在执行过程中请求新的资源，系统可以拒绝这个请求，从而避免死锁。这种方法的缺点是可能导致资源的低效使用，因为进程可能在等待资源时闲置。
    破坏不可剥夺条件：允许操作系统在必要时从进程中剥夺资源，并将其分配给其他进程。这要求操作系统能够跟踪资源的分配情况，并在必要时进行资源回收。这种方法可能会影响系统的响应时间，因为进程可能在执行关键操作时被中断。
    破坏循环等待条件：为所有资源分配一个唯一的编号，并要求进程按照编号顺序请求资源。这样，如果存在循环等待，系统可以检测到并采取措施，如拒绝请求或重新分配资源。
    
    死锁避免：在系统运行时动态地确保系统始终处于安全状态，即不会发生死锁。这通常需要使用银行家算法（Banker's Algorithm）等资源分配策略。
    
    死锁检测和恢复：允许死锁发生，但系统能够检测到死锁，并采取措施恢复。这可能包括终止一个或多个进程，回收其资源，然后重新分配给其他进程。
    
    资源分配图：使用资源分配图（Resource Allocation Graph）来检测死锁。如果图中存在循环，则表示存在死锁。
    
    超时和重试：在数据库系统中，可以设置事务等待锁的超时时间。如果超时，事务可以回滚并重试，这有助于打破循环等待条件。
    
    死锁检测算法：如等待图（Wait-for Graph）算法，通过构建等待图来检测死锁。如果图中存在循环，则表示存在死锁。
    
    在实际应用中，解决死锁问题通常需要结合预防、避免和恢复策略，以及对系统资源的合理分配和管理。例如，在Java多线程编程中，可以通过使用synchronized关键字或ReentrantLock来管理锁，以及合理设计资源请求和释放的顺序，来避免死锁的发生。
    ```

8. PV原语
    ```python
    PV原语（P操作和V操作）是进程同步和互斥的基本概念，由荷兰计算机科学家Edsger Dijkstra提出。它们是操作系统中用于控制对共享资源访问的一组原子操作，确保在多进程环境中，进程能够安全地访问临界资源。
    
    P操作（Proberen，测试）：
    
    P操作用于请求资源。当一个进程执行P操作时，它会尝试获取一个信号量（Semaphore）的值。如果信号量的值大于0（表示资源可用），则信号量的值减1，进程继续执行；如果信号量的值小于或等于0（表示资源不可用），则进程将被阻塞，直到有其他进程执行V操作释放资源。
    V操作（Verhogen，增加）：
    
    V操作用于释放资源。当一个进程执行V操作时，它会将信号量的值增加1。如果信号量的值在执行V操作之前是负数（表示有进程在等待资源），则操作系统会选择一个等待的进程，将其唤醒，允许它继续执行。
    PV原语的执行是原子的，即在执行过程中不会被其他进程中断。这种原子性保证了进程在访问临界资源时的同步和互斥，防止了竞态条件（Race Condition）的发生。
    
    在实际应用中，PV原语可以用于实现多种同步机制，例如：
    
    互斥：通过设置一个初始值为1的信号量，可以确保任何时候只有一个进程能够进入临界区。
    同步：通过设置信号量来表示某个条件是否满足，进程在执行前必须等待条件满足（P操作），条件满足后其他进程可以继续执行（V操作）。
    PV原语是操作系统中实现进程间同步和互斥的基础，广泛应用于多线程编程、并发控制和资源管理等领域。
    ```

9. 有哪些调度算法
    ```python
    调度算法是操作系统中用于决定哪个进程应该获得CPU时间的一种策略。不同的调度算法有不同的目标和特点，以下是一些常见的调度算法：
    
    先来先服务（FCFS，First-Come, First-Served）：
    
    按照进程到达就绪队列的顺序进行调度，先到达的进程先执行。这种算法简单易实现，但可能导致短作业等待时间长。
    短作业优先（SJF，Shortest Job First）：
    
    优先调度预计执行时间最短的进程。这可以减少平均等待时间，但可能导致长作业饥饿（Starvation）。
    优先级调度：
    
    根据进程的优先级进行调度，优先级高的进程先执行。优先级可以是静态的（固定不变）或动态的（随时间或进程状态变化）。
    最高响应比优先（HRRN，Highest Response Ratio Next）：
    
    结合了FCFS和SJF的优点，使用响应比（等待时间加执行时间与执行时间的比值）来决定调度顺序。
    时间片轮转（RR，Round Robin）：
    
    每个进程被分配一个固定的时间片，进程在时间片内执行。如果时间片结束进程未完成，它会被放回队列末尾等待下一轮调度。
    多级反馈队列（MLFQ，Multilevel Feedback Queue）：
    
    结合了时间片轮转和优先级调度，将进程分为多个优先级队列，根据进程的行为（如是否频繁阻塞）动态调整其优先级。
    最短剩余时间优先（SRTF，Shortest Remaining Time First）：
    
    类似于SJF，但在抢占式环境下，如果新到达的进程剩余执行时间短于当前正在执行进程的剩余时间，当前进程会被抢占。
    实时调度（Real-Time Scheduling）：
    
    用于实时系统，确保任务在截止时间前完成。这通常需要严格的时间保证和优先级策略。
    每种调度算法都有其适用场景和优缺点。在实际应用中，操作系统可能会根据系统需求和目标选择合适的调度算法，或者结合多种算法来优化性能。
    ```

10. 页面置换算法：
    ```python
    页面置换算法是虚拟内存管理中用于决定哪些页面应该从物理内存中移除以便为新页面腾出空间的策略。以下是一些常见的页面置换算法：
    
    先进先出（FIFO，First-In, First-Out）：
    
    选择最早进入内存的页面进行置换。这种算法简单易实现，但可能会导致频繁使用的页面被错误地置换出去。
    最近最久未使用（LRU，Least Recently Used）：
    
    选择最长时间未被访问的页面进行置换。LRU算法试图保留最近被访问的页面，但实现起来比较复杂，因为需要跟踪每个页面的访问时间。
    时钟页面置换（Clock Algorithm）：
    
    类似于LRU，但使用一个循环队列来模拟时钟指针。指针指向的页面是下一个被置换的候选页面。当页面被访问时，它的访问位被设置，指针向前移动。如果指针到达队列末尾，所有访问位被重置，指针回到队列开头。
    最佳页面置换（OPT，Optimal Page Replacement）：
    
    理论上的最优算法，选择未来最长时间不会被访问的页面进行置换。这种算法无法在实际中实现，因为它需要预知未来的页面访问模式。
    最近未使用（NRU，Not Recently Used）：
    
    类似于时钟算法，但不需要重置访问位。它通过一个计数器来跟踪页面的访问频率，计数器值最小的页面被置换。
    最不常用（LFU，Least Frequently Used）：
    
    选择访问次数最少的页面进行置换。这种算法需要维护每个页面的访问计数，可能会保留一些长时间未使用但访问次数仍然较高的页面。
    最常使用（MFU，Most Frequently Used）：
    
    与LFU相反，选择访问次数最多的页面进行置换。这种算法假设访问频率高的页面在未来也会被频繁访问。
    工作集页面置换（Working Set Page Replacement）：
    
    基于工作集模型，工作集是进程在一段时间内访问的页面集合。算法试图保持工作集内的页面在内存中，而将工作集外的页面置换出去。
    老化算法（Aging Algorithm）：
    
    对NRU算法的改进，通过定期减少页面的计数器值来模拟页面的“老化”，以避免长时间未使用的页面因为计数器值过高而不会被置换。
    这些算法各有优缺点，实际应用中可能会根据系统的具体需求和资源限制选择合适的页面置换策略。在实际的操作系统实现中，LRU和时钟算法是比较常见的选择。
    ```

11. 程序的并发控制
    ```python
    程序的并发控制是计算机科学中的一个重要概念，特别是在多线程、多进程和分布式系统中，它确保多个执行单元（如线程或进程）能够安全、有效地共享资源，同时避免竞态条件、死锁和其他并发问题。以下是一些常见的并发控制机制和策略：
    
    互斥（Mutex）：
    
    互斥锁是一种同步机制，它允许在同一时间只有一个线程访问共享资源。当一个线程获取互斥锁时，其他线程必须等待直到锁被释放。
    信号量（Semaphore）：
    
    信号量是一个计数器，用于控制对共享资源的访问。它可以限制同时访问某个资源的线程数量，通常用于实现生产者-消费者问题。
    读写锁（ReadWrite Lock）：
    
    读写锁允许多个读操作并发进行，但写操作时必须独占资源。这在读取操作远多于写入操作的场景中非常有用。
    原子操作（Atomic Operations）：
    
    原子操作是不可分割的操作，它们在执行过程中不会被其他线程中断。原子操作通常用于实现无锁（lock-free）数据结构。
    条件变量（Condition Variables）：
    
    条件变量允许线程等待某个条件成立，或者在条件变化时唤醒等待的线程。它们通常与互斥锁一起使用，以实现复杂的同步逻辑。
    屏障（Barrier）：
    
    屏障是一种同步机制，它确保所有参与的线程在继续执行之前都达到了某个同步点。
    乐观并发控制（Optimistic Concurrency Control, OCC）：
    
    乐观并发控制假设冲突很少发生，允许多个线程尝试修改数据，只有在实际发生冲突时才进行回退和重试。
    悲观并发控制（Pessimistic Concurrency Control）：
    
    悲观并发控制假设冲突经常发生，因此在数据被修改前就进行锁定，以防止冲突。
    事务（Transactions）：
    
    在数据库系统中，事务提供了一种机制，确保一系列操作要么全部成功，要么全部失败，保持数据的一致性。
    锁的粒度（Lock Granularity）：
    
    锁的粒度可以从细粒度（如行级锁）到粗粒度（如表级锁）不等。细粒度锁可以减少锁的竞争，提高并发性能，但可能增加管理开销。
    锁的类型（Lock Types）：
    
    除了互斥锁，还有读写锁、自旋锁、可重入锁等不同类型，每种锁都有其特定的用途和性能特点。
    在实际应用中，选择合适的并发控制策略取决于具体的应用场景和性能要求。例如，在Java中，可以使用synchronized关键字、ReentrantLock、AtomicInteger等来实现并发控制。在分布式系统中，可能需要使用更复杂的协议，如Paxos或Raft，来确保数据的一致性和系统的可用性。
    ```

12. UML是什么？
    ```python
    UML（Unified Modeling Language，统一建模语言）是一种用于软件开发和系统设计的标准化建模语言。它提供了一套图形化的工具，帮助开发者、系统分析师和架构师在软件开发过程中表达、可视化、构建和文档化系统的设计。UML的主要目的是为了促进软件开发团队之间的沟通，以及提高软件开发的效率和质量。
    
    UML包括了一系列的图表（Diagrams），每种图表都有其特定的用途，用于描述系统的不同方面：
    
    用例图（Use Case Diagram）：描述系统的功能需求，以及用户（参与者）与系统之间的交互。
    
    类图（Class Diagram）：展示系统中的类、接口、对象之间的关系，如继承、关联、依赖等。
    
    对象图（Object Diagram）：是类图的实例，展示了系统中具体对象的实例及其关系。
    
    组件图（Component Diagram）：描述系统的物理结构，包括组件、包以及它们之间的关系。
    
    部署图（Deployment Diagram）：展示系统的物理部署，包括硬件、软件组件以及它们在网络中的分布。
    
    序列图（Sequence Diagram）：描述对象之间如何交互，以及交互的顺序。
    
    协作图（Collaboration Diagram）：与序列图类似，但更侧重于对象之间的组织结构。
    
    状态图（State Diagram）：描述对象在其生命周期中可能的状态以及状态之间的转换。
    
    活动图（Activity Diagram）：描述业务流程或工作流程，展示活动的流程和决策点。
    
    通信图（Communication Diagram）：与协作图类似，但更侧重于消息的传递。
    
    UML的这些图表可以单独使用，也可以组合使用，以全面描述系统的各个方面。UML的标准化使得不同团队和组织能够使用相同的语言和符号来交流，从而提高了软件项目的可理解性和可维护性。UML广泛应用于面向对象的分析和设计（OOAD）过程中，是现代软件工程实践中不可或缺的一部分。
    ```

13. 软件工程生命周期
    ```python
    软件工程生命周期（Software Development Life Cycle，SDLC）是描述软件从概念化、设计、实现、测试、部署到维护和最终退役的整个过程。这个过程通常包括多个阶段，每个阶段都有其特定的目标和活动。软件工程生命周期的目的是确保软件项目能够高效、系统地进行，同时保证软件质量和满足用户需求。以下是软件工程生命周期的主要阶段：
    
    需求分析（Requirements Analysis）：
    
    确定软件需要实现的功能和性能指标，收集用户需求，编写需求规格说明书。
    系统设计（System Design）：
    
    根据需求分析的结果，设计软件的架构，包括系统的整体结构、模块划分、接口设计等。
    详细设计（Detailed Design）：
    
    在系统设计的基础上，进一步细化每个模块的设计，包括数据结构、算法、类设计等。
    编码（Coding）：
    
    根据详细设计文档，编写源代码，实现软件的功能。
    测试（Testing）：
    
    对软件进行各种类型的测试，如单元测试、集成测试、系统测试和验收测试，确保软件满足需求且无重大缺陷。
    部署（Deployment）：
    
    将软件部署到生产环境，进行安装、配置和初始化。
    维护（Maintenance）：
    
    在软件投入使用后，根据用户反馈进行必要的修改和优化，包括修复缺陷、更新功能、性能优化等。
    退役（Retirement）：
    
    当软件不再满足业务需求或被新技术替代时，进行退役处理，包括数据迁移、用户培训、文档归档等。
    软件工程生命周期可以采用不同的开发模型，如瀑布模型（Waterfall Model）、迭代模型（Iterative Model）、螺旋模型（Spiral Model）和敏捷开发（Agile Development）等。这些模型在软件开发的不同阶段有不同的侧重点和流程安排。随着软件开发实践的发展，敏捷开发方法因其灵活性和快速响应变化的能力而越来越受欢迎。
    ```

14. 软件开发步骤是什么？软件开发模型有哪些？
    ```python
    软件开发步骤通常遵循一个结构化的流程，这个流程可能因项目、团队和采用的开发模型而异。以下是一般的软件开发步骤：
    
    项目启动：
    
    确定项目目标、范围和可行性。
    组建项目团队。
    制定项目计划和预算。
    需求分析：
    
    与利益相关者沟通，明确软件需求。
    分析需求，编写需求规格说明书。
    系统设计：
    
    设计软件架构和系统组件。
    设计数据库和数据模型。
    确定技术栈和开发工具。
    编码：
    
    根据设计文档编写源代码。
    实现软件功能。
    测试：
    
    进行单元测试、集成测试、系统测试和用户接受测试。
    修复发现的缺陷。
    部署：
    
    将软件部署到生产环境。
    配置和优化系统。
    维护：
    
    监控软件性能，处理用户反馈。
    定期更新和升级软件。
    项目收尾：
    
    完成项目文档。
    评估项目成果和过程。
    软件开发模型是指导软件开发过程的结构框架，常见的软件开发模型包括：
    
    瀑布模型（Waterfall Model）：
    
    线性顺序，每个阶段完成后才能进入下一个阶段。
    适用于需求明确、变化较少的项目。
    迭代模型（Iterative Model）：
    
    分阶段开发，每个阶段产生可交付的软件。
    适用于需求可能变化的项目。
    增量模型（Incremental Model）：
    
    分模块开发，逐步增加新功能。
    适用于大型复杂系统。
    螺旋模型（Spiral Model）：
    
    结合了瀑布模型和原型模型，强调风险分析。
    适用于风险较高的项目。
    原型模型（Prototype Model）：
    
    快速构建原型，验证概念或需求。
    适用于需求不明确或需要快速反馈的项目。
    敏捷开发（Agile Development）：
    
    强调快速响应变化，持续交付可工作的软件。
    适用于需求不断变化的项目。
    喷泉模型（Fountain Model）：
    
    面向对象的开发模型，强调迭代和并行开发。
    适用于面向对象的软件开发。
    V模型（V-Model）：
    
    开发和测试活动并行进行，强调测试的重要性。
    适用于安全性和质量要求高的项目。
    RUP（Rational Unified Process）：
    
    基于用例驱动的迭代和增量开发过程。
    适用于大型企业级应用开发。
    极限编程（XP, Extreme Programming）：
    
    强调团队协作、持续集成和快速反馈。
    适用于快速迭代和高度变化的项目。
    选择哪种开发模型取决于项目的特点、团队的偏好以及组织的能力。在实际应用中，团队可能会结合多种模型的特点来适应项目的具体需求。
    ```

    