C++
1. 已知int array[10] = {1,2,3}，仅将数组名作为实参传递给函数，下列说法正确的是( )
A. 数组会退化为指针
B. 实际传递给形参的是数组的第一个元素值
C. 实际传递给形参的是数组中全部元素的值
D. 可以在函数中获得数组元素的个数

2、下面哪个语句在C++中属于合法的函数重载方式？
A. void func(int x);void func2(double x)
B. int func(int x);double func(int x)
C. void func(int x);void func(int y)
D. void func(int x);void func(int x, int y)

3、下面哪种方式可以用来初始化整数类型的数组为全0？
A. int arr[5];
B. int arr[5] = {1, 2, 3, 4, 5};
C. int arr[5] = {};
D. 不确定，与编译器的处理方式有关


4、在C++中，指针和引用之间的主要区别是什么？
A. 指针可以为NULL，引用不能为NULL。
B. 指针可以重新赋值，引用不能重新赋值。
C. 指针需要分配空间，存储的是内存地址；而引用不分配内存，相当于别名。
D. 指针可以指向其他指针，引用不能指向其他引用。

5. 下面关于多态性的描述中，哪个是不正确的？（ ）
A. 多态性可以实现同一个方法在不同对象上具有不同的行为
B. 多态性只能使用虚函数来实现
C. 多态性是面向对象编程的重要特性之一
D. 多态性包括动态多态和静态多态

6. 下面关于纯虚函数的描述中，哪个是正确的？（ ）
A. 没有实现纯虚函数的类可以实例化
B. 没有实现纯虚函数的类不可以作为指针
C. virtual void fun()=0，声明fun为纯虚函数
D. 继承了包含纯虚函数的类，就必须实现继承的纯虚函数

7. 在排序方法中，关键码比较次数与记录的初始排列无关的是( )
A. 快速排序
B. 归并排序
C. 冒泡排序
D. 选择排序

8. 一个的数据结构，一端只能出，另一端既可以进也可以出，数据入栈序列是A，B，C，D，E，则出栈序列不可能是（ ）
A. EACBD；
B. DECBA；
C. DCEAB；
D. ABCDE；

9.下列语句中，存在错误的是（ ）
A. int a=1; int &p = a;
B. char a[10]; char *p = &a;
C. const int a=1; const int &p= a;
D. int a; float p=a;

10 在C++中，以下哪个选项描述了私有继承的特点？
A. 派生类可以访问基类的私有成员。
B. 基类的私有成员在派生类中具有相同的访问级别。
C. 基类的公有成员在派生类中变为私有成员。
D. 对象之间的转换要求基类和派生类之间存在具有公有访问级别的继承关系。

11 下列关于数据成员的说法，不正确的是( )
A. 所有对象共享同一个静态成员变量的副本
B. protected成员可以在类的内部但不可以在派生类中访问
C. this是指向当前对象的指针，它可以被用来引用对象的成员变量
D. 普通的成员函数可以直接访问类中的静态数据成员

12 联函数的描述，正确的是( )
A. 内联函数可以提高程序效率
B. 内联函数的调用过程与普通函数一样
C. 只要用 inline 关键字声明的函数都是内联函数
D. 全局函数不能声明为内联函数

13 下面是关于派生类析构函数的执行顺序的叙述：
①执行派生类自身的析构函数，即派生类中定义的析构函数。
②执行基类的析构函数，按照继承关系从派生类的直接基类到最顶层的基类逐层执行。
③如果派生类中存在虚基类，那么在基类析构函数执行完毕后，会执行派生类中虚基类的析构函数。上述执行步骤的正确排序是( )
A. ①②③ B. ②①③ C. ③②① D. ②③①

14 相较于C，以下哪种方式是C++特有的内存分配方式
A. new 操作符
B. delete 操作符
C. malloc 函数
D. free 函数


15在 C++ 中，以下哪种运算符具有最高的优先级（）C
A. &&
B. !
C. *
D. /

16在C++中，以下哪个标准库头文件用于输入和输出操作？
A. iostream
B. vector
C. string
D. algorithm

17 下列关于抽象类描述不正确的是( )
A. 抽象类不能定义对象
B. 其派生类没有定义纯虚函数，则仍是抽象类。”
C. 其派生类定义所有纯虚函数，则是具体类
D. 不能定义指向抽象类的指针变量

18 下面关于友元函数和友元类的叙述中，错误的是( )
A. 如果在类A中把类B的某个函数声明为自己的友元函数，那么在类A的定义之前一定要有类B的完整定义
B. 如果在类A中把类B声明为自己的友元类，那么在类A的定义之前可以仅有类B的前向声明，而不必有类B的完整定义
C. 如果将类B声明为类A的友元，那么类A也就成为类B的友元
D. 如果将类B声明为类A的友元，那么类B中的函数可以访问类A的全部成员


19 在C++中，以下哪个操作符用于在条件语句中同时执行两个条件的逻辑与操作（）
A. &&
B. ||
C. !
D. &

20关于this指针的用途下列说法错误的是（）
A.在成员函数中访问成员变量：通过this指针，可以访问到对象的成员变量，这样可以避免与局部变量或参数重名的冲突
B.this指针是一个指向对象的指针，因此可以对其进行解引用操作来访问对象的成员变量和成员函数
C.this指针不允许进行链式调用
D.在静态成员函数中不能使用this指针，因为静态成员函数是与类本身关联的，而不是与类的实例关联的

21 于虚函数的描述中，错误的是()
A.C++中的虚函数是一种特殊的成员函数，用于实现继承
B.通过使用虚函数，可以在基类中定义通用的接口，然后在派生类中根据需要进行重写
C.在派生类中，可以选择性地重写虚函数
D.虚函数还可以声明为纯虚函数，在基类中只给出函数原型，而没有函数体


22 （多选）this指针存在的目的是（ ）
A.在C++中，this是一个特殊的指针，用于在类的成员函数中指向当前对象的指针
B.this指针指向调用成员函数的对象本身，可以通过this指针访问对象的成员变量和成员函数
C.this指针是一个隐藏的参数，在每个成员函数的内部都可以访问该指针
D.当需要访问成员变量或调用其他成员函数时，默认会通过this指针来实现

23 下面对静态数据成员的描述中，错误的是( )
A.在C++中，静态成员函数（Static Member Function）是与类的实例对象相关联的函数，而不是与类相关联
B.静态成员函数与类的静态数据成员相关联，它们共享相同的内存空间
C.静态成员函数可以访问和修改类的静态数据成员，但不能访问非静态的成员变量和成员函数
D.由于静态成员函数没有隐式的this指针，因此无法访问非静态成员变量，也无法调用非静态成员函数

24 下面对友元函数的描述中正确的是 ( )
A.友元函数（Friend Function）是一种特殊类型的函数，允许函数访问其它类的私有成员或保护成员
B.友元函数只可以定义在类的内部
C.友元函数不能继承，因此子类不能继承父类的友元函数
D.友元函数也不能被重载

25 关于拷贝构造函数下列说法错误的是( )
A.拷贝构造函数可以有多个参数
B.将对象作为函数返回值时，构造函数可能会被隐式调用
C.用一个对象初始化另一个对象，构造函数可能会被隐式调用
D.将对象作为函数参数传递给函数，构造函数可能会被隐式调用

26 带默认参数的函数原型声明若有：void fun(int a,int b=7,char z=’’);下面函数调用中，不合法的是( )
A. fun(1); B. fun(1,2);
C. fun( ); D. fun(1,2,‘a’);


27 下面有关重载函数的说法中正确的是( )
1.函数名称相同 2.函数参数列表不同 3.函数返回类型可以相同也可以不同
4.函数重载无法用于非成员函数
A.123
B.134
C.234
D.124

28 下面有关重载函数的说法中，错误的是( )
A.在C++中，函数重载（Function Overloading）是指在同一作用域内定义具有相同名称但参数列表不同的多个函数。
B.函数重载可以让程序员使用相同的函数名来表示不同的操作或功能，提高了代码的可读性和灵活性
C.函数重载的实现原理是根据函数的参数列表来区分不同的函数。
D.当调用一个重载函数时，编译器无法根据实际参数的类型和个数，自动匹配并调用对应的重载函数。

29下列关于多继承二义性的描述中，错误的是 ( )
A.在C++中，多继承是允许一个类从多个基类派生的特性
B.在C++中，可以使用作用域限定符来指定要调用的成员函数所属的基类
C.虚继承是一种继承方式，可以用于解决由多条继承路径引起的二义性问题
D.多继承二义性是多继承的一个潜在问题，但无法通过作用域限定符和虚继承来解决


30 下列有关C++类的说法中，不正确的是( )
A.类可以包含成员变量和成员函数，用于描述对象的属性和行为
B.类中的成员变量（也称为数据成员）用于表示对象的状态或属性
C.在类中，如果不做特别说明，所有成员的访问权限均为私有的
D.类是一种用户自定义的数据类型，用于封装数据和相关的操作
